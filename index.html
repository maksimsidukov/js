<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>



   //Задание 1



   // A. Написать функцию, которая будет принимать строку и на выходе будет отоброжаться стока без пробелов. (Example: F('Hello World'))
    function noSpace(str){
        if(typeof (str) !== 'string')
            return "Input not string";
        return str.split(" ").join("");
    }
    //B. Расширить написанную функцию, следующим образом: на вход теперь будет приходить строка и
    //символ который должен быть исключен из данной строки, на выходе обработанная строка. (Example: F('Hello World', 'e'))
   function noSymbol(str, symbol){
       if(typeof (str) !== 'string')
           return "Input not string";
       return str.split(`${String(symbol)}`).join("");
   }
   // C. Расширить написанную функцию следующим образом: на вход теперь будет приходить строка и массив
   // символов которые должны быть исключены из строки, на выходе обработанная строка. (Example: F('Hello World', ['e', 'o']))
   function noCharacters(str, characters){
       if(typeof (str) !== 'string')
           return "Input not string";
       for (let symbol of characters){
           str.split(`${symbol}`).join('');
       }
       return str;
   }



   //Задание 2



   //A. Написать функцию, которая будет принимать на вход массив целых чисел, на выходе будет массив отсортированный по возрастанию. (Example: F([4, 3, 2, 1]))
    function sort(numbers) {
        return numbers.sort();
    }
   //B. Расширить написанную функцию, на вход будет приниматься массив целых чисел
   // и способ сортировки. (Example: F([4, 3, 2, 1], 'ascending(по возрастанию)/descending(по убыванию)/none(отсутсвует).'))
   function sort2(numbers, way) {
        if(way.toLowerCase() === 'ascending'){
            return numbers.sort(function (a, b) {return a - b;});
        }
        else if(way.toLowerCase() === 'descending'){
            return numbers.sort(function(a, b) {return b - a});
        }
        else if(way.toLowerCase() === 'none'){
            return numbers;
        }
        else{
            return 'way not correct';
        }
   }
   //C. Расширить написанную функцию, на вход будет приниматься массив чисел, способ сортировки
   // и фильтр (использовать только целые числа (integer), только дробные числа (double)
   // или любые числа (any))  (Example: F([4, 3, 2, 1], 'ascending', 'integer' ))

   function filt(numbers, filter){
       if(filter.toLowerCase() === 'integer'){
           return numbers.filter(item => parseInt(item) === item);
       }
       else if(filter.toLowerCase() === 'double'){
           return numbers.filter(item => parseInt(item) !== item);
       }
       else if(filter.toLowerCase() === 'any'){
           return numbers;
       }
       else{
           return 'filter not correct';
       }
   }

   function sort3(numbers, way, filter) {
       numbers = filt(numbers, filter);
       numbers = sort2(numbers, way);
       return numbers
   }



   //Задание 3



    //A. Написать функцию, которая будет принимать два числа и операцию
    //( +, -, *, /, ^), на выходе результат операции. (Example: F(4, 3, '+' ))
    function calculator(num1, num2, operator){
        switch (operator) {
            case '+':
                return num1 + num2;
            case '-':
                return num1 - num2;
            case '*':
                return num1 * num2;
            case '/':
                return num1 / num2;
            case '^':
                return num1 ** num2;
        }
    }
    //B. Расширить функцию, на вход будет приходить массив из массивов, где два
   // числа и операция, на выходе массив с результатом каждой операции. (Example: F([4, 3, '+'], [2, 5, '-'] ))
   function calculator2(){
        let result = [];
        for(let arr of arguments){
            result.push(calculator(arr[0], arr[1], arr[2]))
        }
        return result;
   }
    //C. Расширить функцию, помимо массивов с двумя числами и операцией, в массиве может присутствовать операция,
   // если операции между двумя элементами массива отсутствует
   // использовать операцию '+'. (Example: F([4, 3, '+'], '*',  [2, 5, '-'], [4,6, '+'] )).
   function calculator3(){
       let result = [];
       for(let arr of arguments){
           if(typeof(arr) === 'string')
               result.push(arr);
           else{
               result.push(calculator(arr[0], arr[1], arr[2]))
           }
       }
       result = addPlus(result);
       result = solveArray(result);
       return result;
   }

    //Добавляет '+', между двумя рядом стоящими массивами
   function addPlus(arr){
       let result = [];
       let start = true;
       for(let i in arr){
           if(start) {
               result.push(arr[i]);
               start = false;
           }
           else if(typeof(arr[i]) === 'string'){
               result.push(arr[i]);
           }
           else{
               if(typeof(arr[i-1]) === 'string'){
                   result.push(arr[i]);
               }
               else{
                   result.push('+', arr[i]);
               }
           }
       }
       return result;
   }

   //Ходит по списку и выдает результат всех действий
   function solveArray(arr){
       let result = 0;
       let start = true;
       for(let i = 0; i < arr.length; i++){
           if(start){
               result = arr[i];
               start = false;
           }
           else if(typeof(arr[i]) === 'string'){
               switch (arr[i]) {
                   case '+':
                       result += arr[i+1];
                       break;
                   case '-':
                       result -= arr[i+1];
                       break;
                   case '*':
                       result *= arr[i+1];
                       break;
                   case '/':
                       result /= arr[i+1];
                       break;
                   case '^':
                       result **= arr[i+1];
                       break;
               }
           }
       }
       return result;
   }



   //Задание 4



   class ToolStore{

        constructor(name, type='all', numberSeats) {
            this.name = name;
            this.type = type;
            this.tools = [];
            this.numberSeats = numberSeats;
        }

        toolList(){
            return this.tools;
        }

        addTool(tool, typeTool){
            if(this.numberSeats !== 0) {
                if (this.type.indexOf(typeTool) >= 0 || this.type === "all") {
                    this.tools.push(tool);
                    this.numberSeats--;
                    console.log(`Интсрумент ${tool} добавлен. Осталось ${this.numberSeats} мест!`);
                }
                else {
                    console.log(`Тип инструмента не соответствует типу хранилища! Допустимы типы\n${this.type}`);
                }
            }
            else{
                console.log('Мест нет')
            }
        }

        deleteTool(tool){
            if(this.tools.indexOf(tool) >= 0){
                this.tools.splice(this.tools.indexOf(tool), 1);
                this.numberSeats++;
                console.log(`Интсрумент ${tool} убран. Осталось ${this.numberSeats} мест!`);
            }
            else{
                console.log('tool is not in storage')
            }
        }
   }

   tools1 = new ToolStore('tools','all', 10);



   //Задание 5


   //Напиши функцию создания генератора sequence(start, step). Она при вызове возвращает другую функцию-генератор,
   // которая при каждом вызове дает число на 1 больше, и так до бесконечности. Начальное число, с которого начинать отсчет,
   // и шаг, задается при создании генератора. Шаг можно не указывать, тогда он будет
   // равен одному. Начальное значение по умолчанию равно 0. Генераторов можно создать сколько угодно.

   function sequence(start=0, step=1) {
        let _start = start;
        let _step = step;
        return function () {
            return _start += _step;
        }
   }



   //Задание 6


   //напиши функцию pluck, которая берет массив объектов и возвращает массив значений определенного поля

   function pluck(arr, key) {
        let result = [];
        for(let i of arr){
            result.push(i[key]);
        }
        return result;
   }



   //Задание 7


   //Напиши функцию, считающую число свойств в объекте:

   function count(obj) {
        let count = 0;
        for(let i in obj){
            count++;
        }
        return count;
   }


   //Задание 8


   // В одном городе есть электрическая сеть. К ней могут быть подключены:
   // электростанции, вырабатывают мощность от 1 до 100 мегаватт
   // солнечные панели, генерируют от 1 до 5 мегаватт днем (в зависимости от вида панели, то есть некоторые панели генерируют 1 мегаватт, некоторые 2 и так далее) и 0 ночью
   // жилые дома, в них от 1 до 400 квартир, потребляют 4 кВт на квартиру днем и 1 кВт ночью.
   // линии электропередач, ведущие в другие города, по ним может подаваться недостающая или отдаваться лишняя энергия.
   // У линий есть свойство «мощность», которая определяет, сколько мегаватт можно передать по ней, а также «цена мегаватта»,
   // которое показывает сколько можно получить или придется заплатить за переданный/полученный мегаватт. На разных линиях может быть разная цена.
   // Дан список всех элементов электросети. Напиши программу, рассчитывющую, сколько электричества необходимо закупить
   // (или можно продать) днем и ночью для обеспечения баланса и сколько это будет стоить (или принесет прибыли).
   // Используй продвинутый ООП подход для решения задачи.

    class City{
        constructor(name, powerStation=[], solarPanels=[], houses=[], powerLines=[]) {
            this.name = name;
            this.powerStations = powerStation;
            this.solarPanels = solarPanels;
            this.houses = houses;
            this.powerLines = powerLines;
            this.dayCityPrice = 0;
            this.nightCityPrice = 0;
        }

        //Добавление электростанций
        addPowerStations(powerStation){
            if(powerStation instanceof PowerStation){
                this.powerStations.push(powerStation)
            }
            else{
                console.log('Функция "addPowerStations" принимает только объекты класса "PowerStation"');
            }
        }

        //Добавление солнечных панелей
        addSolarPanel(solarPanel){
            if(solarPanel instanceof SolarPanel){
                this.solarPanels.push(solarPanel)
            }
            else{
                console.log('Функция "addSolarPanel" принимает только объекты класса "SolarPanel"');
            }
        }

        //Добавление домов
        addHouse(house){
            if(house instanceof House){
                this.houses.push(house)
            }
            else{
                console.log('Функция "addHouse" принимает только объекты класса "House"');
            }
        }

        //Добавление электросети
        addPowerLine(powerLine){
            if(powerLine instanceof PowerLine){
                this.powerLines.push(powerLine);
                //Сортируеться список электросетей(вначале с большей ценой)
                this.powerLines.sort(function(a, b){
                    if(a.price < b.price){
                        return 1;
                    }
                    if(a.price === b.price){
                        return 0;
                    }
                    if(a.price > b.price){
                        return -1;
                    }
                });
            }
            else{
                console.log('Функция "addPowerLine" принимает только объекты класса "PowerLine"');
            }
        }

        //Расчет вырабатываемой энергии
        energyGenerated(){
            this.dayEnergyGenerated = 0;
            this.nightEnergyGenerated = 0;
            for(let powStat of this.powerStations){
                this.dayEnergyGenerated += powStat.power;
                this.nightEnergyGenerated += powStat.power;
            }
            for(let solPanel of this.solarPanels){
                this.dayEnergyGenerated += solPanel.power;
            }
        }

        //Расчет потребляемой энергии
        energyConsumed(){
            this.dayEnergyConsumed = 0;
            this.nightEnergyConsumed = 0;
            for(let house of this.houses){
                this.dayEnergyConsumed += house.dayEnergyConsumption;
                this.nightEnergyConsumed += house.nightEnergyConsumption;
            }
        }

        //Оценка энергетической ситуации(сколько излишек/нехватка)
        energySituation(){
            this.dayEnergySituaion = this.dayEnergyGenerated - this.dayEnergyConsumed;
            this.nightEnergySituation = this.nightEnergyGenerated - this.nightEnergyConsumed
        }

        //Возможности электросетей
        opportunitiesPowerLines() {
            this.opportunitiesPowerLine = 0;
            for (let powLine of this.powerLines) {
                this.opportunitiesPowerLine += powLine.power;
            }
        }

        //Хватит ли электросетей для закупки/продажи электричества
        decisionSituation(){
            if(this.opportunitiesPowerLine > Math.abs(this.dayEnergySituaion) && this.opportunitiesPowerLine > Math.abs(this.nightEnergySituation)){
                return true;
            }
            else{
                return false;
            }
        }

        //Расчет стоимости(при закупке большая часть пытаеться закупиться по наименьшей стоимости, при продаже наоборот)
        costElectricity(){
            if(this.dayEnergySituaion >= 0){
                let i = 0;
                let dayLeftoverEnergy = this.dayEnergySituaion;
                while(dayLeftoverEnergy !== 0){
                    if(this.powerLines[i].power > dayLeftoverEnergy){
                        this.dayCityPrice += dayLeftoverEnergy * this.powerLines[i].price;
                        dayLeftoverEnergy = 0;
                    }
                    else{
                        this.dayCityPrice += powerLines[i].power * this.powerLines[i].price;
                        dayLeftoverEnergy -= powerLines[i].power;
                        i++;
                    }
                }
            }
            if(this.dayEnergySituaion < 0){
                let i = 0;
                let dayLeftoverEnergy = this.dayEnergySituaion;
                while(dayLeftoverEnergy !== 0){
                    if(this.powerLines[this.powerLines.length - i - 1].power > dayLeftoverEnergy){
                        this.dayCityPrice += dayLeftoverEnergy * this.powerLines[this.powerLines.length - i - 1].price;
                        dayLeftoverEnergy = 0;
                    }
                    else{
                        this.dayCityPrice += powerLines[i].power * this.powerLines[this.powerLines.length - i - 1].price;
                        dayLeftoverEnergy -= powerLines[i].power;
                        i++;
                    }
                }
            }


            if(this.nightEnergySituation >= 0){
                let i = 0;
                let nightLeftoverEnergy = this.nightEnergySituation;
                while(nightLeftoverEnergy !== 0){
                    if(this.powerLines[i].power > nightLeftoverEnergy){
                        this.nightCityPrice += nightLeftoverEnergy * this.powerLines[i].price;
                        nightLeftoverEnergy = 0;
                    }
                    else{
                        this.nightCityPrice += powerLines[i].power * this.powerLines[i].price;
                        nightLeftoverEnergy -= powerLines[i].power;
                        i++;
                    }
                }
            }
            if(this.nightEnergySituation < 0){
                let i = 0;
                let nightLeftoverEnergy = this.nightEnergySituation;
                while(nightLeftoverEnergy !== 0){
                    if(this.powerLines[this.powerLines.length - i - 1].power > nightLeftoverEnergy){
                        this.nightCityPrice += nightLeftoverEnergy * this.powerLines[this.powerLines.length - i - 1].price;
                        nightLeftoverEnergy = 0;
                    }
                    else{
                        this.nightCityPrice += powerLines[i].power * this.powerLines[this.powerLines.length - i - 1].price;
                        nightLeftoverEnergy -= powerLines[i].power;
                        i++;
                    }
                }
            }

        }

        //Функция которая сама выполняет все функции по расчетам и выводит результат в консоль
        cityAnalysis(){
            this.energyGenerated();
            this.energyConsumed();
            this.energySituation();
            this.opportunitiesPowerLines();
            this.costElectricity();
            console.log(`Город ${this.name} вырабатывает ${this.dayEnergyGenerated}кВт днем и ${this.nightEnergyGenerated}кВт ночью!`);
            console.log(`Расходует днем ${this.dayEnergyConsumed}кВт, ночью ${this.nightEnergyConsumed}кВт`);
            console.log(`Ситуация: Днем ${this.dayEnergySituaion}, ночью ${this.nightEnergySituation}`);
            console.log(`Возможности электросетей ${this.opportunitiesPowerLine}`);
            if(this.decisionSituation()){
                console.log('Электросетей для покупки/продажи хватит!')
            }
            else{
                console.log('Электросетей для покупки/продажи НЕ хватит!')
            }
            console.log(`Затраты/заработок: Днем ${this.dayCityPrice}, ночью ${this.nightCityPrice}`)
        }
    }

    //Энергия вводится в мегаваттах
    class PowerStation{
       constructor(power) {
           this.power = power*1000
       }
    }

   //Энергия вводится в мегаваттах
    class SolarPanel{
       constructor(power) {
           this.power = power * 1000
       }
    }

   //Энергия вводится в киловаттах
    class House{
       constructor(quantityApartments) {
           this.quantityApartments = quantityApartments;
           this.dayEnergyConsumption = quantityApartments * 4;
           this.nightEnergyConsumption = quantityApartments;
       }
    }

   //Энергия вводится в мегаваттах
    class PowerLine{
       constructor(power, price) {
           this.power = power * 1000;
           this.price = price;
       }
    }

    city = new City('Москва');

    PowStat1 = new PowerStation(100);
    PowStat2 = new PowerStation(100);
    SolPanel1 = new SolarPanel(2);
    SolPanel2 = new SolarPanel(3);
    //Дома с таким количеством квартир что бы не создавать много домов
    house1 = new House(2000);
    house2 = new House(10000);
    powLine1 = new PowerLine(1000, 15);
    powLine2 = new PowerLine(500, 20);

    city.addPowerStations(PowStat1);
    city.addPowerStations(PowStat2);
    city.addSolarPanel(SolPanel1);
    city.addSolarPanel(SolPanel2);
    city.addHouse(house1);
    city.addHouse(house2);
    city.addPowerLine(powLine1);
    city.addPowerLine(powLine2);
    city.cityAnalysis();



    //Задание 9


   //напиши функцию, определяющую тип переменной. Результат должен быть одной из
   // строк: 'undefined', 'boolean' (для true/false), 'null', 'number', 'string',
   // 'function', 'array', 'array-like', 'object'
    function myTypeof(obj){
        switch(typeof (obj)){
            case "undefined":
                return 'undefined';
            case "boolean":
                return 'boolean';
            case "number":
                return 'number';
            case "string":
                return 'string';
            case "function":
                return "function";
            case "object":
                if(obj === null) {
                    return "null"
                }
                else if(obj instanceof Array) {
                    return "array";
                }
                else if(typeof(obj.callee) === 'function'){
                    return "array-like";
                }
                else{
                    return "object";
                }
        }
    }




    //Задание 10


    //Напиши функцию глубокого копирования объектов и массивов.

    function deepCopy(obj){
        let copy;
        if (null == obj || typeof(obj) !== 'object') {
            return obj;
        }
        else if (obj instanceof Array) {
            copy = [];
            obj.forEach(function (i) {
                copy.push(deepCopy(obj[i]))
            });
            return copy;
        }
        else if (obj instanceof Object) {
            copy = {};
            for (let i in obj) {
                copy[i] = deepCopy(obj[i]);
            }
            return copy;
        }
        else{
            return'The function copies only arrays and objects.'
    }
    }

</script>
</html>
